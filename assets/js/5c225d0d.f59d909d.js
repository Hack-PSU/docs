"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[210],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=a.createContext({}),l=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=l(e.components);return a.createElement(p.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=l(t),m=r,h=c["".concat(p,".").concat(m)]||c[m]||d[m]||i;return t?a.createElement(h,o(o({ref:n},u),{},{components:t})):a.createElement(h,o({ref:n},u))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=m;var s={};for(var p in n)hasOwnProperty.call(n,p)&&(s[p]=n[p]);s.originalType=e,s[c]="string"==typeof e?e:r,o[1]=s;for(var l=2;l<i;l++)o[l]=t[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},7391:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var a=t(7462),r=(t(7294),t(3905));const i={sidebar_position:4,id:"api"},o="API",s={unversionedId:"admin-web-app/api",id:"admin-web-app/api",title:"API",description:"Another operation the admin web app relies heavily on is data fetching from multiple api. Currently, in API V2,",source:"@site/docs/admin-web-app/04-API.md",sourceDirName:"admin-web-app",slug:"/admin-web-app/api",permalink:"/docs/admin-web-app/api",draft:!1,editUrl:"https://github.com/Hack-PSU/docs/docs/admin-web-app/04-API.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,id:"api"},sidebar:"mobileApp",previous:{title:"Form Handling",permalink:"/docs/admin-web-app/form-handling"},next:{title:"Components",permalink:"/docs/category/components"}},p={},l=[{value:"Authorization",id:"authorization",level:2},{value:"Endpoints",id:"endpoints",level:2},{value:"Entities",id:"entities",level:3},{value:"Queries",id:"queries",level:3},{value:"Endpoint Definitions",id:"endpoint-definitions",level:4},{value:"Query Keys",id:"query-keys",level:4},{value:"Fetching",id:"fetching",level:2},{value:"Caching",id:"caching",level:2}],u={toc:l};function c(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"api"},"API"),(0,r.kt)("p",null,"Another operation the admin web app relies heavily on is data fetching from multiple api. Currently, in API V2,\nthe data api, notification api, and WebSocket api are separated as they have conflicting requirements. "),(0,r.kt)("h2",{id:"authorization"},"Authorization"),(0,r.kt)("p",null,"To make sure that all requests are made with the correct authorization, every request made to each api will always be\nsent using a Firebase Auth token. To abstract this logic, we use Axios interceptors and perform a token refresh\nwhenever a request fails."),(0,r.kt)("p",null,"We can build an api integration like the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const api = axios.create({\n  baseURL: "https://api-base-url.com"  // insert baseURL\n});\n\napi.interceptors.response.use(\n  (response) => response,\n  async (error) => {\n    const request = error.config;\n    const isRefreshNeeded =\n      shouldRefreshToken(request) &&\n      error.response.status === 401 && \n      !request._retried;\n    \n    if (isRefreshNeeded) {\n      request._retried = true;\n      await refreshToken(request, api, true);\n    }\n    return Promise.reject(error);\n  }\n);\n')),(0,r.kt)("p",null,"The full implementation of each function in the snippet can be found\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Hack-PSU/admin-web-app/blob/main/common/api/axios.ts"},"here"),". In order to fully integrate the api\ninto the Firebase Auth lifecycle, we need to watch for user refreshes and token revokes."),(0,r.kt)("p",null,"The following can be found in the\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Hack-PSU/admin-web-app/blob/main/components/context/FirebaseProvider.tsx"},(0,r.kt)("inlineCode",{parentName:"a"},"FirebaseProvider")),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// in api integration file\nconst initApi = async (user: User) => {\n  if (user) {\n    instance.defaults.headers.common["idtoken"] = await getIdToken(user);\n  }\n};\n\nconst resetApi = () => {\n  delete instance.defaults.headers.common["idtoken"];\n  delete instance.defaults.headers.common["exp"];\n};\n\n// in FirebaseProvider\nuseEffect(() => {\n  return onIdTokenChanged(auth, async (user) => {\n    if (user) {\n      await initApi(user);\n    } else {\n      resetApi();\n    }\n  })\n}, [auth]);\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"initApi")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"resetApi")," initializes and destroys an instance of the api integration. The former is to inject\nthe user token into the api headers and the latter is to remove it."),(0,r.kt)("h2",{id:"endpoints"},"Endpoints"),(0,r.kt)("p",null,"API endpoints define the separation of caching for data fetches. To create a more robust integration with caching,\nwe use ",(0,r.kt)("a",{parentName:"p",href:"https://tanstack.com/query/v4/docs/react/overview"},"React Query"),", which will allow us to invalidate\nqueries declaratively and react to data changes across multiple pages."),(0,r.kt)("p",null,"React Query uses a concept called ",(0,r.kt)("inlineCode",{parentName:"p"},"QueryKeys")," to generate ",(0,r.kt)("em",{parentName:"p"},"keys")," that will be used to identify cached data. The way\nwe define a ",(0,r.kt)("inlineCode",{parentName:"p"},"QueryKey")," is flexible, but to maintain consistency across all ",(0,r.kt)("inlineCode",{parentName:"p"},"QueryKeys")," we use the following format\nto integrate a new API endpoint."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"common\n\u2514\u2500\u2500 api\n    \u2514\u2500\u2500 <endpoint entity>\n        \u251c\u2500\u2500 entity.ts\n        \u251c\u2500\u2500 index.ts \n        \u2514\u2500\u2500 queries.ts \n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"index.ts")," file exports all entities from ",(0,r.kt)("inlineCode",{parentName:"p"},"entity.ts")," and all queries and query keys from ",(0,r.kt)("inlineCode",{parentName:"p"},"queries.ts"),".\nThis is known as a ",(0,r.kt)("em",{parentName:"p"},"barrel")," file."),(0,r.kt)("h3",{id:"entities"},"Entities"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"entity.ts")," contains all type interfaces that all endpoint queries will use. This can include any request or\nresponse objects."),(0,r.kt)("h3",{id:"queries"},"Queries"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"queries.ts")," file can be broken up into 2 sections, the endpoint definitions and the query key definitions."),(0,r.kt)("h4",{id:"endpoint-definitions"},"Endpoint Definitions"),(0,r.kt)("p",null,"There are a number of abstractions created to easily create endpoint definitions. This ensures:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Type consistency when used in pages"),(0,r.kt)("li",{parentName:"ol"},"Type inference when using React Query"),(0,r.kt)("li",{parentName:"ol"},"Consistency across interfaces used to fetch data")),(0,r.kt)("p",null,"To create a query or a ",(0,r.kt)("inlineCode",{parentName:"p"},"GET")," request, we use:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'export const getEndpoint: CreateQueryReturn<\n  IResponseObject,\n  Params\n> = createQuery<IResponseObject>("/get/endpoint");\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"CreateQueryReturn")," type generic ensures easy integration with the ",(0,r.kt)("inlineCode",{parentName:"p"},"fetch")," function explained ",(0,r.kt)("a",{parentName:"p",href:"#fetching"},"below"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type ApiResponse<TData> = {\n  api_response: string;\n  status: number;\n  body: {\n    status: string;\n    data: TData;\n  };\n};\n\ntype QueryReturn<TResponse> = AxiosResponse<ApiResponse<TResponse>>;\n\ntype CreateQueryReturn<TResponse, TParam = {}> = (\n  params?: TParam,\n  token?: string,\n) => Promise<QueryReturn<TResponse>>;\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"createQuery")," function is a closure that takes in a string for the endpoint to query and returns another\nfunction that allows customization of query params when fetching using React Query. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type createQuery = <TResponse, TParam = {}>(\n  url: string,\n  instance: ApiAxiosInstance = api\n) => CreateQueryReturn<TResponse, TParam>\n")),(0,r.kt)("p",null,"To create a mutation, such as a ",(0,r.kt)("inlineCode",{parentName:"p"},"POST")," or a ",(0,r.kt)("inlineCode",{parentName:"p"},"PATCH")," request:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'export const postEndpoint: CreateMutationReturn<\n  IRequestEntity,\n  IResponseEntity\n> = createMutation("/post/endpoint");\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"CreateMutationReturn")," type generic ensures the same integration as ",(0,r.kt)("inlineCode",{parentName:"p"},"CreateQueryReturn"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type CreateMutationReturn<TEntity, TResponse = TEntity, TParam = {}> = (\n  entity: TEntity,\n  params?: TParam,\n  token?: string\n) => Promise<QueryReturn<TResponse>>\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"createMutation")," function is a closure that takes in the url endpoint and an optional method."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'type createMutation = <TEntity, TResponse, TParam = {}>(\n  url: string,\n  method: Method = "POST",\n  instance: ApiAxiosInstance = api\n) => CreateMutationReturn<TEntity, TResponse, TParam>\n')),(0,r.kt)("h4",{id:"query-keys"},"Query Keys"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"QueryKeys")," control the keys used to manage cache and invalidate them. To manage ",(0,r.kt)("inlineCode",{parentName:"p"},"QueryKeys")," in a more deterministic\napproach, we use the following ",(0,r.kt)("inlineCode",{parentName:"p"},"QueryKey")," factory. We will use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Event")," endpoint entity as an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// in queries.ts\nexport const EventKeys = {\n  all: [{ entity: "event" }] as const,\n  findAll: () =>\n    [\n      {\n        ...EventKeys.all[0], action: QueryAction.query, scope: QueryScope.ALL\n      }\n    ] as const,\n  findById: (id: string | number) => \n    [{ ...EventKeys.all[0], action: QueryACtion.query, scope: id }] as const,\n  update: (id: string | number) =>\n    [{ ...EventKeys.all[0], action: QueryAction.update, scope: id }] as const,\n  delete: (id: string | number) =>\n    [{ ...EventKeys.all[0], action: QueryAction.delete, scope: id }] as const,\n};\n')),(0,r.kt)("p",null,"We can then export the query keys for this endpoint together with other ",(0,r.kt)("inlineCode",{parentName:"p"},"QueryKeys")," of other endpoints. We define\nthis in ",(0,r.kt)("inlineCode",{parentName:"p"},"common/api/index.ts"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// in common/api/index.ts\nimport { EventKeys } from \"./event\"\n\nexport const QueryKeys = {\n  //...insert other query keys\n  event: EventKeys,\n};\n\nexport * from './event';\n")),(0,r.kt)("h2",{id:"fetching"},"Fetching"),(0,r.kt)("p",null,"We can use ",(0,r.kt)("inlineCode",{parentName:"p"},"QueryKeys")," and the endpoints defined above to integrate with React Query."),(0,r.kt)("p",null,"To compensate for the structure of the api response, we use the ",(0,r.kt)("inlineCode",{parentName:"p"},"fetch")," function to extract the response. This makes\ntype inferencing easier for TypeScript and reduce the need to pass in type generics into the ",(0,r.kt)("inlineCode",{parentName:"p"},"useQuery")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"useMutation"),"\nhooks."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type fetch = <TResponse>(\n  queryFn: () => Promise<QueryReturn<TResponse>>\n) => Promise<TResponse | undefined>\n")),(0,r.kt)("p",null,"To perform a ",(0,r.kt)("inlineCode",{parentName:"p"},"GET")," request, we can use the\n",(0,r.kt)("a",{parentName:"p",href:"https://tanstack.com/query/v4/docs/react/reference/useQuery"},(0,r.kt)("inlineCode",{parentName:"a"},"useQuery")),"\nhook:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { data } = useQuery(\n  QueryKeys.event.findOne(),\n  () => fetch(getEndpoint),\n);\n")),(0,r.kt)("p",null,"To perform a ",(0,r.kt)("inlineCode",{parentName:"p"},"POST")," request, we can use the\n",(0,r.kt)("a",{parentName:"p",href:"https://tanstack.com/query/v4/docs/react/reference/useMutation"},(0,r.kt)("inlineCode",{parentName:"a"},"useMutation")),"\nhook:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { mutateAsync } = useMutation(\n  ({ entity }) => fetch(() => postEndpoint(entity))\n);\n")),(0,r.kt)("h2",{id:"caching"},"Caching"),(0,r.kt)("p",null,"Using React Query we can manage caching by invalidating caches after performing any request that can change the data.\nFor example, we can invalidate the cache corresponding to all event endpoints when we add a new event to refresh\nthe event table:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const queryClient = useQueryClient();\n\nconst { mutateAsync } = useMutation(\n  ({ entity }) => fetch(() => postEndpoint(entity)),\n  {\n    onSuccess: async () => {\n      await queryClient.invalidateQueries(QueryKeys.event.all);\n    }\n  }\n);\n")))}c.isMDXComponent=!0}}]);